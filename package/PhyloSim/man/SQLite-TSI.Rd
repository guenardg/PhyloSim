% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SQliteTSSI-functions.R
\name{SQLite-TSI}
\alias{SQLite-TSI}
\alias{connectNetwork}
\alias{ClearNetwork}
\alias{makeLinearNetwork}
\alias{makeTreeNetwork}
\alias{makeReticulatedNetwork}
\alias{clearNetwork}
\alias{drawDNASequence}
\alias{drawEvolRate}
\alias{simulateSequence}
\alias{simulateTrait}
\alias{getSequence}
\title{SQLite Trait Simulation Interface}
\usage{
connectNetwork(name, init = FALSE)

clearNetwork(net, delete = FALSE)

makeLinearNetwork(net, NS, NC, timestep, root = TRUE, verbose = FALSE)

makeTreeNetwork(net, NS, NC, timestep, root = TRUE, verbose = FALSE)

makeReticulatedNetwork(
  net,
  NS,
  NC,
  NP,
  timestep,
  maxDiss,
  contrib,
  root = TRUE,
  verbose = FALSE
)

drawDNASequence(NN, prob = c(0.3, rep(0.175, 4L)))

drawEvolRate(NN, gamma.shape = 5, gamma.scale = 5e-04)

simulateSequence(net, I, name, sqn, rate, note = "")

simulateTrait(net, tem, name, state, value, note = "")

getSequence(net, name, removeGapOnly = TRUE)
}
\arguments{
\item{name}{The name of the SQLite database, sequence, or trait to be created
(character).}

\item{init}{Whether or not to initialize the SQLite database upon creation
(logical).}

\item{net}{A two elements list containing the name of the database an a
SQLite database connection from function \code{\link[DBI]{dbConnect}}.}

\item{delete}{Whether to delete the database file upon closing the database.}

\item{NS}{The number of sequences to generate (integer).}

\item{NC}{A function without arguments returning the simulated number of
children for each ancestor (see details).}

\item{timestep}{A function (without arguments) returning the value (numeric)
of the time step during the simulation (see details).}

\item{root}{Whether to root the series or not (logical; default:
\code{TRUE}). It is carried out on new data series (a single lineage, tree,
or network) and set to \code{FALSE} when extending an existing data series
(see details).}

\item{verbose}{Whether to print details about the simulation process during
the calculations (logical; default: \code{FALSE}).}

\item{NP}{A function without arguments returning the number of parents during
a hybridization event.}

\item{maxDiss}{The maximum distance (in term of the value of argument
\code{timestep}.)}

\item{contrib}{A function returning the relative contribution of the
different parents during an hybridization event.}

\item{NN}{The number of locations to be generated (integer). A locations is
either one of the four nucleotides or a gap).}

\item{prob}{Probabilities for drawing a gap (-) or one of the for DNA bases
(A, C, G, or T), in that order (A length 5 numeric vector). Default:
\code{c(0.3,0.175,0.175,0.175,0.175)}. Probabilities not summing to 1 will be
made to sum to 1.}

\item{gamma.shape}{Shape parameter of the beta distribution used to draw the
nucleotide (and gaps) evolution rates (numeric).}

\item{gamma.scale}{Scale parameter of the beta distribution used to draw the
nucleotide (and gaps) evolution rates (numeric).}

\item{I}{A 5 x 5 transition intensity matrix (see
\code{\link[PhyloSim]{molEvolMod}} for details).}

\item{sqn}{A raw vector containing the seed sequence used at the root of the
network.}

\item{rate}{A vector of nucleotide evolution rates (numeric).}

\item{note}{Note about the trait to be stored in the SQLite database.}

\item{tem}{A trait evolution model (see \code{\link[PhyloSim]{traitEvolMod}}
for the details.)}

\item{state}{For a trait evolving according to an Ornstein Uhlenbeck process,
trait state at the onset of the simulation.}

\item{value}{Value of the trait at the onset of the simulation.}

\item{removeGapOnly}{Remove positions that are all gaps from the output
(logical; default: \code{TRUE}).}
}
\value{
\describe{
  \item{connectNetwork}{A two elements list containing the name of the
  database an a SQLite database connection from function
  \code{\link[DBI]{dbConnect}}.}
  \item{clearNetwork}{\code{NULL} (invisibly).}
  \item{makeLinearNetwork}{The number of the last node that has been
  created.}
  \item{makeTreeNetwork}{The number of the last node that has been created.}
  \item{makeReticulatedNetwork}{The number of the last node that has been
  created.}
  \item{drawDNASequence}{A raw vector of length \code{NN} containing the
  ASCII values for characters '-' (0x2d), 'A' (0x41), 'C' (0x43), 'G' (0x47),
  and 'T' (0x54) representing random nucleotides to be used as the seed
  sequence for a DNA fragment.}
  \item{drawEvolRate}{A numeric vectors of length \code{NN} containing the
  evolution rate for each of the nucleotides in the sequence.}
  \item{simulateSequence}{\code{NULL} (invisibly).}
  \item{simulateTrait}{\code{NULL} (invisibly).}
  \item{getSequence}{A vector of type character.}
}
}
\description{
A database interface for simulating traits along evolutionaly time on linear
evolutionary series, phylogenerit trees, or phylogenetic networks.
}
\details{
Details here...
}
\section{Functions}{
\itemize{
\item \code{connectNetwork()}: Create Network

Create an SQLite database in which to simulate various evolutionary series.

\item \code{clearNetwork()}: Clear Network

Close an SQLite database, possibly deleting the database file.

\item \code{makeLinearNetwork()}: Linear Evolutionary Series

Simulates a linear evolutionary series.

\item \code{makeTreeNetwork()}: Phylogenetic Tree

Simulates a phylogenetic tree.

\item \code{makeReticulatedNetwork()}: Phylogenetic Network

Simulates a phylogenetic network.

\item \code{drawDNASequence()}: Random Sequence Generator

Generates a random sequence of gaps or DNA bases.

\item \code{drawEvolRate()}: Random Evolution Rate Generator

Generates a set of random nucleotide evolution rate from a gamma
distribution.

\item \code{simulateSequence()}: Sequence Evolution Simulator

Generates a set of DNA sequences along the edge of a phylogenetic network by
evolving filial sequences from parental ones following a random Markov
process.

\item \code{simulateTrait()}: Trait Evolution Simulator

Simulates the evolution of a quantitative traits following a random walk
process.

\item \code{getSequence()}: Sequence Exractor

Extracts all sequences of a given fragment from a phylogenetic network.

}}
\examples{
## Load the example of a configuration file provided with the
## package:
system.file(
  package = "PhyloSim",
  "extdata",
  "evolMod.yml"
) \%>\%
  yaml.load_file -> dnaParam

## The configuration list is located in member `$DNA`
dnaParam$DNA \%>\%
  read.mutationMat -> I

## The transition intensity matrix:
I

## The trait evolution model parameters:
dnaParam$trait \%>\%
  lapply(read.TraitEvolMod) -> traitMod


### Linear case:

## Initializing a new data base to store the network:
net <- connectNetwork(name = "net_linear", init = TRUE)

## Setting RNG seed to have a consistent example:
set.seed(162745)

## These are the tables that are created in the database:
dbListTables(net$con)

## The following code enables one to extract the SQLite table information:
lapply(
  dbListTables(net$con),
  function(x, con)
    dbGetQuery(con, sprintf("PRAGMA table_info(\%s)", x)),
  con = net$con
) -> table_info

names(table_info) <- dbListTables(net$con)

table_info

## The following code retrieves the number of records in all the tables.
## All of them are empty at the beginning of the simulation:
sapply(
  dbListTables(net$con),
  function(x, con)
    unlist(
      dbGetQuery(
        con,
        sprintf(
          "SELECT COUNT(*) AS \%s
         FROM \%s",
          x,x),
      )
    ),
  con = net$con
)

## Create a linear network with 50 species having 1 descendant each with a
## constant time step of 1:
makeLinearNetwork(
  net = net,
  NS = 50,
  NC = function() 1,
  timestep = function() 1,
  root = TRUE,
  verbose = TRUE
)

## After the linear phylogenetic network has been created, tables diss, edge,
## and node conntain information. The other tables are used for storing the
## sequence and trait information.
sapply(
  dbListTables(net$con),
  function(x, con)
    unlist(
      dbGetQuery(
        con,
        sprintf("SELECT COUNT(*) FROM \%s", x),
      )
    ),
  con = net$con
)

## Simulate two sequences, one named 'SEQ1' having 100 locations (i.e., one
## of the four nucleotide or a gap) and a second sequence named 'SEQ2' having
## 250 locations.
data.frame(
  name = c("SEQ1","SEQ2"),
  NN = c(100,250)
) -> cond

## Calling function simulateSequence once for each of the simulated
## sequences, each time drawing a random root sequence (using
## drawDNASequence) and a set of evolution rate (using function
## drawEvolRate).
for(i in 1:NROW(cond))
  simulateSequence(
    net,
    I,
    name = cond$name[i],
    sqn = drawDNASequence(cond$NN[i]),
    rate = drawEvolRate(cond$NN[i])
  )

## Now, tables seq and seq_content contain information:
sapply(
  dbListTables(net$con),
  function(x, con)
    unlist(
      dbGetQuery(
        con,
        sprintf("SELECT COUNT(*) FROM \%s", x),
      )
    ),
  con = net$con
)

## Show the first sequence (here, the y-axis corresponds to the time step):
net \%>\%
  getSequence(name = "SEQ1") \%>\%
  concatenate(discard = "-") \%>\%
  show.sequence

## Show the second sequence:
net \%>\%
  getSequence(name = "SEQ2") \%>\%
  concatenate(discard = "-") \%>\%
  show.sequence

## Set four traits to be simulated.
data.frame(
  name = sprintf("trait\%d",1:4),
  state = c(2,NA,1,1),
  value = c(50,0,15,-25),
  note = c("Non-neutral (OU) with multiple optima","Neutral",
           "Non-neutral (OU) with single optimum",
           "Non-neutral (OU) with single optimum")
) -> cond

## The four traits are simulated as follows:
for(i in 1:NROW(cond))
  simulateTrait(
    net,
    tem = traitEvolMod(traitMod[[i]]),
    name = cond$name[i],
    state = cond$state[i],
    value = cond$value[i],
    note = cond$note[i]
  )

## Now, tables trait and trait_content also contain information:
sapply(
  dbListTables(net$con),
  function(x, con)
    unlist(
      dbGetQuery(
        con,
        sprintf("SELECT COUNT(*) FROM \%s", x),
      )
    ),
  con = net$con
)

## To obtain the trait values at the nodes, one has to use an SQL query (in
## the SQLite dialect) as follows:
lapply(
  sprintf("trait\%d",1:4),
  function(x, con)
    dbGetQuery(
      con,
      sprintf(
        "SELECT trait_content.node, trait_content.optim, trait_content.value
         FROM trait_content
         JOIN trait ON trait.rowid = trait_content.trait
         WHERE trait.name = '\%s'
         ORDER BY trait_content.node",
        x
      )
    ),
  con = net$con
) -> sim_trait

## Plot the trait simulation results:
par(mar=c(4,4,1,1))
plot(NA, xlim=c(0,50), xlab="Time", ylab="Trait value", las=1,
     ylim=range(-25,sapply(sim_trait, function(x) x$value),80))
col <- c("black","red","blue","green")

## The solid line is the trait value, whereas the dotted line is the
## effective trait optimum:
for(i in 1:4) {
  lines(x=0:49, y=sim_trait[[i]]$value, col=col[i])
  if(!all(is.na(sim_trait[[i]]$optim)))
    lines(x=0:49, y=sim_trait[[i]]$optim, col=col[i], lty=3)
}
## Note: there are no effective optimum for a trait evolving neutrally.

## Clear the simulated linear network:
clearNetwork(net, TRUE)


### Tree case:

## Initializing a new data base to store the network:
net <- connectNetwork(name = "net_linear", init = TRUE)

## Setting RNG seed to have a consistent example:
set.seed(162745)

## Create a tree network (phylogenetic tree) with 100 species having
## a fix number of 2 descendants (dichotomic) and a random log-normal time
## step drawn at each time step:
makeTreeNetwork(
  net = net,
  NS = 100,
  NC = function() 2,
  timestep = function() exp(rnorm(1,0,0.5)),
  root = TRUE,
  verbose = TRUE
)

## Simulate two sequences, one named 'SEQ1' having 50 locations (i.e., one of
## the four nucleotide or a gap) and a second sequence named 'SEQ2' having 80
## locations.
data.frame(
  name = c("SEQ1","SEQ2"),
  NN = c(50,80)
) -> cond

## Calling function simulateSequence once for each of the simulated
## sequences, each time drawing a random root sequence (using
## drawDNASequence) and a set of evolution rate (using function
## drawEvolRate).
for(i in 1:NROW(cond))
  simulateSequence(
    net,
    I,
    name = cond$name[i],
    sqn = drawDNASequence(cond$NN[i]),
    rate = 10*drawEvolRate(cond$NN[i])  ## Accelerate evolution by 10 folds
  )

## Set four traits to be simulated.
data.frame(
  name = sprintf("trait\%d",1:4),
  state = c(2,NA,1,1),
  value = c(50,0,15,-25),
  note = c("Non-neutral (OU) with multiple optima","Neutral",
           "Non-neutral (OU) with single optimum",
           "Non-neutral (OU) with single optimum")
) -> cond

## The four traits are simulated as follows:
for(i in 1:NROW(cond))
  simulateTrait(
    net,
    tem = traitEvolMod(traitMod[[i]]),
    name = cond$name[i],
    state = cond$state[i],
    value = cond$value[i],
    note = cond$note[i]
  )

## To obtain the trait values at the nodes, one has to use an SQL query (in
## the SQLite dialect) as follows:
lapply(
  sprintf("trait\%d",1:4),
  function(x, con)
    dbGetQuery(
      con,
      sprintf(
        "SELECT trait_content.node, trait_content.optim, trait_content.value
         FROM trait_content
         JOIN trait ON trait.rowid = trait_content.trait
         WHERE trait.name = '\%s'
         ORDER BY trait_content.node",
        x
      )
    ),
  con = net$con
) -> sim_trait

## Showing the sequences and traits evolving is not as straightforward for a
## phylogenetic tree as it is for a linear sequence of descendants.

## We first need to retrieve the edge list as follows:
dbGetQuery(
  net$con,
  "SELECT i,j FROM edge ORDER BY rowid"
) -> edge

## From that list, we can determine which node is a leaf:
leaf <- edge$j[!(edge$j \%in\% unique(edge$i))]
leaf

## We can use this simple function to obtain lineage of any node:
getLineage <- function(x, e) {
  while(length(wh <- which(e$j == head(x,1))))
    x <- c(e$i[wh], x)
  unname(x)
}

## Here is the lineage of the first leaf:
getLineage(leaf[1], edge)

## Show the first sequence (here, the y-axis corresponds to the time step):
net \%>\%
  getSequence(name = "SEQ1") \%>\%
  .[getLineage(leaf[1], edge),] \%>\%
  concatenate(discard = "-") \%>\%
  show.sequence

## Show the second sequence:
net \%>\%
  getSequence(name = "SEQ2") \%>\%
  .[getLineage(leaf[1], edge),] \%>\%
  concatenate(discard = "-") \%>\%
  show.sequence

## Obtain the distances between the root node and all the nodes:
rbind(
  list(1L,0),
  dbGetQuery(
    net$con,
    "SELECT j, d FROM diss WHERE i = 1 ORDER BY j"
  )
) -> dst

## Function to show every lineages 'l':
plotit <- function(l) {
  nn <- getLineage(leaf[l], edge)
  dd <- dst$d[match(nn, dst$j)]
  
  ## Plot the trait simulation results:
  par(mar=c(4,4,1,1))
  plot(NA, xlim=range(dd), xlab="Time", ylab="Trait value", las=1,
       ylim=range(-25,sapply(sim_trait, function(x) x$value),80))
  col <- c("black","red","blue","green")
  
  ## The solid line is the trait value, whereas the dotted line is the
  ## effective trait optimum:
  for(i in 1:4) {
    lines(x=dd, y=sim_trait[[i]]$value[match(nn, dst$j)], col=col[i])
    if(!all(is.na(sim_trait[[i]]$optim)))
      lines(x=dd, y=sim_trait[[i]]$optim[match(nn, dst$j)], col=col[i],
            lty=3)
  }
  ## Note: there are no effective optimum for a trait evolving neutrally.
}

## Plot the lineages of some of the leaves:
plotit(1)
plotit(2)
plotit(3)
plotit(6)
plotit(7)

## Clear the simulated linear network:
clearNetwork(net, TRUE)


### The reticulated case:

## Initializing a new data base to store the network:
net <- connectNetwork(name = "net_reticulated", init = TRUE)
## clearNetwork(net, TRUE)

## Setting RNG seed to have a consistent example:
set.seed(162745)

## Create a reticulated network with 100 species having a random number of
## descendants and parents per node, a random log-normal time step, a random
## maximum hybridization distance, and equal parental contributions on
## hybridization events.
makeReticulatedNetwork(
  net,
  NS = 100,
  NC = function() 1 + rpois(1,2),
  NP = function() 1 + rpois(1,1),
  timestep = function() exp(rnorm(1,0,0.5)),
  maxDiss = function() runif(1, 2, 3),
  contrib = function(x) rep(1/x,x),
  root = TRUE,
  verbose = TRUE
)

## Simulate one sequence named 'SEQ1' having 50 locations (i.e., one of
## the four nucleotide or a gap). Calling function simulateSequence drawing a
## random root sequence (using drawDNASequence) and a set of evolution rate
## (using function drawEvolRate).
simulateSequence(
  net,
  I,
  name = "SEQ1",
  sqn = drawDNASequence(50),
  rate = 10*drawEvolRate(50)  ## Accelerate evolution by 10 folds
)

## Set four traits to be simulated.
data.frame(
  name = sprintf("trait\%d",1:4),
  state = c(2,NA,1,1),
  value = c(50,0,15,-25),
  note = c("Non-neutral (OU) with multiple optima","Neutral",
           "Non-neutral (OU) with single optimum",
           "Non-neutral (OU) with single optimum")
) -> cond

## The four traits are simulated as follows:
for(i in 1:NROW(cond))
  simulateTrait(
    net,
    tem = traitEvolMod(traitMod[[i]]),
    name = cond$name[i],
    state = cond$state[i],
    value = cond$value[i],
    note = cond$note[i]
  )

## To obtain the trait values at the nodes, one has to use an SQL query (in
## the SQLite dialect) as follows:
lapply(
  sprintf("trait\%d",1:4),
  function(x, con)
    dbGetQuery(
      con,
      sprintf(
        "SELECT trait_content.node, trait_content.optim, trait_content.value
         FROM trait_content
         JOIN trait ON trait.rowid = trait_content.trait
         WHERE trait.name = '\%s'
         ORDER BY trait_content.node",
        x
      )
    ),
  con = net$con
) -> sim_trait

## Showing the sequences and traits evolving is even less straightforward for
## a reticulated phylogenetic network as it is for a phylogenetic tree, let
## alone for a linear sequence of descendants.

## We first need to retrieve the edge list as follows (same as for a tree):
dbGetQuery(
  net$con,
  "SELECT i,j FROM edge ORDER BY rowid"
) -> edge

## From that list, we can determine which node is a leaf (also same as for a
## tree):
leaf <- unique(edge$j[!(edge$j \%in\% unique(edge$i))])
leaf

## Obtain the distances between the root node and all the nodes:
rbind(
  list(1L,0),
  dbGetQuery(
    net$con,
    "SELECT j, d FROM diss WHERE i = 1 ORDER BY j"
  )
) -> dst

## To obtain simple lineage, we need a criterion to choose which parent to
## follow at hybridization events. Here, the parent that is the closest to
## the root is the one chosen:
getLineageDR <- function(x, e, d) {
  while(length(wh <- which(e$j == head(x,1)))) {
    wh <- wh[which.min(d$d[match(e$i[wh],d$j)])]
    x <- c(e$i[wh], x)
  }
  unname(x)
}

## Here is the lineage of the first leaf of the network:
getLineageDR(leaf[1], edge, dst)

## Show the sequences of the lineage of the first leaf:
net \%>\%
  getSequence(name = "SEQ1") \%>\%
  .[getLineageDR(leaf[1], edge, dst),] \%>\%
  concatenate(discard = "-") \%>\%
  show.sequence

## Show the sequences of the lineage of the second leaf:
net \%>\%
  getSequence(name = "SEQ1") \%>\%
  .[getLineageDR(leaf[2], edge, dst),] \%>\%
  concatenate(discard = "-") \%>\%
  show.sequence

## Show the sequences of the lineage of the third leaf:
net \%>\%
  getSequence(name = "SEQ1") \%>\%
  .[getLineageDR(leaf[6], edge, dst),] \%>\%
  concatenate(discard = "-") \%>\%
  show.sequence

## Function to show every lineages 'l':
plotit <- function(l) {
  nn <- getLineageDR(leaf[l], edge, dst)
  dd <- dst$d[match(nn, dst$j)]
  
  ## Plot the trait simulation results:
  par(mar=c(4,4,1,1))
  plot(NA, xlim=range(dd), xlab="Time", ylab="Trait value", las=1,
       ylim=range(-25,sapply(sim_trait, function(x) x$value),80))
  col <- c("black","red","blue","green")
  
  ## The solid line is the trait value, whereas the dotted line is the
  ## effective trait optimum:
  for(i in 1:4) {
    lines(x=dd, y=sim_trait[[i]]$value[match(nn, dst$j)], col=col[i])
    if(!all(is.na(sim_trait[[i]]$optim)))
      lines(x=dd, y=sim_trait[[i]]$optim[match(nn, dst$j)], col=col[i],
            lty=3)
  }
  ## Note: there are no effective optimum for a trait evolving neutrally.
}

## Plot the lineages of some of the leaves:
plotit(7)
plotit(15)
plotit(22)
plotit(length(leaf))

## Clear the simulated linear network:
clearNetwork(net, TRUE)

}
