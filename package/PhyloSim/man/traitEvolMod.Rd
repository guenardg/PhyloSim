% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/traitEvolMod.R
\name{traitEvolMod}
\alias{traitEvolMod}
\alias{read.TraitEvolMod}
\alias{TEM-class}
\alias{print.TEM}
\title{Trait Evolution Simulator}
\usage{
read.TraitEvolMod(cfg)

traitEvolMod(par)

\method{print}{TEM}(x, ...)
}
\arguments{
\item{cfg}{A list containing the configuration parameters needed to construct
an evolution model a single quantitative trait.}

\item{par}{A list containing the parameters, such as the ones provided by
\code{read.TraitEvolMod}, that are needed to build a quantitative trait
evolution model (see details).}

\item{x}{A TEM-class object.}

\item{...}{further arguments to be passed to other functions and methods}
}
\value{
\describe{
  \item{ \code{read.TraitEvolMod} }{...}
  \item{ \code{traitEvolMod} }{...}
}
}
\description{
Functions to simulate the evolution of traits as an
Ornstein-Uhlenbeck process, optionally with trait optimal value evolving
following a Markov process.
}
\details{
...
}
\examples{
## Load the example of a configuration file provided with the
## package:
yaml.load_file(
  system.file(
    package = "PhyloSim",
    "extdata",
    "evolMod.yml"
  )
) -> dnaParam

## This file contains four trait configurations.

## The first trait file appears as follows:

dnaParam$trait[[1]]

## The second, third, fourth appears as follows:

dnaParam$trait[[2]]

dnaParam$trait[[3]]

## and

dnaParam$trait[[4]]

## The configuration list is obtained from the raw file as follows:

cfg <- read.TraitEvolMod(dnaParam$trait[[1]])
cfg

## All four lists are obtained as follows:

cfg <- lapply(dnaParam$trait, read.TraitEvolMod)

cfg[[1]]

cfg[[2]]

cfg[[3]]

cfg[[4]]

## The four trait evolution models can also be obtained at once as
## follows:
tem <- lapply(cfg, traitEvolMod)

## The first model is non-neutral with three optima:
tem[[1]]

## The second model is neutral:
tem[[2]]

## The third model is non-neutral with a single optimum:
tem[[3]]

## The fourth trait is also non-neutral with a single optimum (but having a
## different value than the latter):
tem[[4]]

## Each model has a set of embedded member functions that can be called
## directly.

## Member $getName() returns the name of the trait as follows:
unlist(lapply(tem, function(x) x$getName()))

## Member $getStep() returns the step sizes for the traits as follows:
unlist(lapply(tem, function(x) x$getStep()))

## Member $setStep() sets the step sizes as follows:
lapply(tem, function(x) x$setStep(0.1))

## and returns the recalculated transition probability matrix of models
## having a transition intensity matrix (i.e., for non-neutral models with
## multiple trait optima).

## This is the modified step sizes:
unlist(lapply(tem, function(x) x$getStep()))

## Member $getOptima() returns the model optimum (if available) or a vector
## of model optima (if multiple optima are available) as follows:
lapply(tem, function(x) x$getOptima())

## Member $getTransition() returns the transition intensity matrix, when
## available (NULL otherwise) as follows:
lapply(tem, function(x) x$getTransition())

## Member $getProb() returns the transition intensity matrix, whenever
## available (NULL otherwise) as follows:
lapply(tem, function(x) x$getProb())

## When multiple optima are available, member $updateState() enables to
## simulate the transition from one optimal trait state (the one given as the
## argument) to another (the one which is returned by the function):
state <- 1
newstate <- tem[[1]]$updateState(state)
newstate

## Member $updateValue() simulates the evolution of the trait from one value
## to another. For a non-neutral with multiple optima, The trait state is
## provided using argument state (default: 1, which is the only applicable
## value for a single optimum).
oldvalue <- 31.5
newvalue <- tem[[1]]$updateValue(oldvalue, state=1)
newvalue

## Member $dumpConfig() returns the configuration list, which can be used

cfg2 <- lapply(tem, function(x) x$dumpConfig())
tem2 <- lapply(cfg2, traitEvolMod)
tem2

## Clean up:
rm(cfg2, tem2)

## Simulate trait evolution using the four models described previously:

## Set step size to 0.05
lapply(tem, function(x, a) x$setStep(a), a = 0.05)

## Results list:
res <- NULL
trNms <- lapply(tem, function(x) x$getName())
res$state <- matrix(NA, 1001L, length(tem), dimnames = list(NULL, trNms))
res$optim <- matrix(NA, 1001L, length(tem), dimnames = list(NULL, trNms))
res$trait <- matrix(NA, 1001L, length(tem), dimnames = list(NULL, trNms))
rm(trNms)

## res$state contains the trait state at the simulation time
## res$optim contains the trait's optimum value at the simulation time
## res$trait contains the trait value at the simulation time

## Setting the optimal state of the four traits at the beginning of the
## simulation period:
res$state[1L,] <- c(2,NA,1,1)  ## NBL trait #2 evolves neutrally.

## Getting the trait optima at the beginning of the simulation period:
unlist(
  lapply(
    tem,
    function(x)
      x$getOptima()[res$state[1L,x$getName()]]
  )
) -> res$optim[1L,]

## Setting the initial trait values:
res$trait[1L,] <- c(50,0,15,-25)

## The state of the simulation at the beginning of the simulation:
head(res$state)
head(res$optim)
head(res$trait)

## Setting RNG state to obtain 
set.seed(1234567)

## This loop simulates time steps #2 through #1001
for(i in 2L:1001L) {

  ## Simulate the evolution of the trait states (if relevant, which it is
  ## only for the first trait):
  unlist(
    lapply(
      tem,
      function(x)
        x$updateState(res$state[i - 1L,x$getName()])
    ) 
  )-> res$state[i,]
  
  ## Obtain the optimal trait value (relevant for all traits but the second,
  ## trait, which evolves neutrally):
  unlist(
    lapply(
      tem,
      function(x)
        x$getOptima()[res$state[i,x$getName()]]
    )
  ) -> res$optim[i,]
  
  ## Simulate the evolution of the trait value:
  unlist(
    lapply(
      tem,
      function(x)
        x$updateValue(
          state = res$state[i,x$getName()],
          value = res$trait[i - 1L,x$getName()]
        )
    )
  ) -> res$trait[i,]
}

## Plot the results:
par(mar=c(4,4,1,1))
plot(NA, xlim=c(0,0.05*1000), ylim=range(res$trait), xlab="Time",
     ylab="Trait value", las=1L)
lines(x=0.05*(0:1000), y=res$trait[,1L], col="black")
if(!is.na(tem[[1L]]$getOptima())[1L])
  lines(x=0.05*(0:1000), y=res$optim[,1L], col="black", lty=3L)
lines(x=0.05*(0:1000), y=res$trait[,2L], col="red")
if(!is.na(tem[[2L]]$getOptima())[1L])
  lines(x=0.05*(0:1000), y=res$optim[,2L], col="red", lty=3L)
lines(x=0.05*(0:1000), y=res$trait[,3L], col="blue")
if(!is.na(tem[[3L]]$getOptima())[1L])
  lines(x=0.05*(0:1000), y=res$optim[,3L], col="blue", lty=3L)
lines(x=0.05*(0:1000), y=res$trait[,4L], col="green")
if(!is.na(tem[[4L]]$getOptima())[1L])
  lines(x=0.05*(0:1000), y=res$optim[,4L], col="green", lty=3L)

## Save the figure to a PNG file:
dev.copy(png, filename="Trait value simulation (linear).png", width=600,
height=400)
dev.off()

}
\author{
\packageAuthor{PhyloSim}
}
