% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulate_network.R
\name{simulate_network}
\alias{simulate_network}
\title{Simulation of DNA Sequences Evolution Along the Edge of a Phylogenetic
Network}
\usage{
simulate_network(
  I,
  NS,
  NN,
  traitMod,
  initState,
  initValue,
  NC = function() 3L,
  NP = function() 2L,
  gamma.shape = 5,
  gamma.scale = 5e-04,
  timestep = 1,
  maxDst = 4 * timestep,
  prob = c(0.3, rep(0.175, 4L)),
  removeGapOnly = TRUE,
  verbose = TRUE
)
}
\arguments{
\item{I}{A 5 x 5 transition intensity matrix such as the one obtained from
function \code{read.mutationMat}.}

\item{NS}{The number of sequences to generate.}

\item{NN}{The number of nucleotides for each of the sequence.}

\item{traitMod}{Trait evolution parameters used to generate trait values
alongside the sequences (optional, no trait is generated when missing).}

\item{initState}{If argument \code{traitMod} is given, the initial state of
traits with multiple optima is specified by this argument (mandatory when
argument \code{traitMod} is given, see details).}

\item{initValue}{If argument \code{traitMod} is given, the initial state of
traits with multiple optima is specified by this argument (see details).}

\item{NC}{A function returning the number of descendents (children) for each
new node created (default: a function returning the value 3).}

\item{NP}{A function returning the number of ascendants (parents) for each
new node created (default: a function returning the value 2, see details).}

\item{gamma.shape}{Shape parameter of the gamma distribution from which the
evolution rates are drawn (see details).}

\item{gamma.scale}{Scale parameter of the gamma distribution from which the
evolution rates are drawn (see details).}

\item{timestep}{Time step of the simulation (default: 1 arbitrary unit of
time per generation).}

\item{maxDst}{The maximum distance between the first parent drawn and any
other parents drawn when more than one parents is involved with the creation
of a descendent node (default: 4 times \code{timestep}).}

\item{prob}{A vector of length 5 giving the probabilities for drawing a gap,
or any one of the four bases (gap, adenine, cytosine, guanine, thymine, in
that order) when generating the first sequence (the ancestor of all the
others; default: \code{c(0.3, 0.175, 0.175, 0.175, 0.175)}).}

\item{removeGapOnly}{A boolean specifying whether gap-only locations should
by removed.}

\item{verbose}{A boolean specifying whether to display information about the
links as the sequences are being created (default: \code{TRUE}).}
}
\value{
A \code{\link{list}} containing the following members:
\describe{
\item{trait}{ A list containing the simulation data for the trait value (see
details). }
\item{rate}{ A numeric vector of the evolution rates of each location (bases
or gaps). }
\item{em}{ A list of molecular evolution models, one for each location. }
\item{sqn}{ A raw matrix containing the sequences, whereby sequences are the
rows and locations are the columns). }
\item{cld}{ An integer vector giving the number of remaining descendents
per node at the end of the simulation process. }
\item{dst}{ A matrix of the distances among the sequences, in terms of the
numbers of time steps between them. }
\item{edge}{ A list of \code{NS} integer vectors giving the index of the
descendents for each of the nodes. }
\item{cont}{ A list of \code{NS} numeric vectors giving the parent's
relative contribution for each of their descendents. }
}
}
\description{
A function to simulate a set of DNA sequences along the edge of
a random phylogenetic network.
}
\details{
The function generate a random phylogenetic network with simulated
DNA data by evolving a set of nucleotides using Markov chain based molecular
evolution models as implemented using function \code{\link{molEvolMod}}.
Optionally, the function can simulate the evolution of a set of quantitative
traits using the approach implemented by function \code{\link{traitEvolMod}}.

The process begins by drawing a set of evolution rates from a gamma
distribution with shape and scale parameters provided from arguments
\code{gamma.shape} and \code{gamma.scale}, respectively, for each of a set of
locations whose number of given by argument \code{NS}. When applicable,
Molecular evolution models generated by function \code{\link{molEvolMod}} are
then implemented individually for each location from the randomly drawn rates
and the transition intensity matrix obtained from a YAML configuration file
using function \code{\link{read.mutationMat}}. Then, an initial DNA sequence
is generated using the probabilities (for gaps or any of the ACGT bases)
provided by argument \code{prob}. Also, a vector of numbers of descendents
per node is is initialized with zeros. Non-zero elements of this vectors
indicate nodes that are allowed to have descendents. With each reproduction
event, the value is decremented by one until the value goes back to zero.
Initial values of this descendant vector are generated by the function passed
through argument \code{NC}.

Once these staging steps are done, each sequence is generated by evolving
each location of an ancestral sequence using the molecular evolution models
until the prescribed number of sequences, provided by argument \code{NS}, is
reached. The ancestral sequence is either one of the previously generated
sequences, or an hybrid of two or more of these sequences. The number of
ascendants is generated by the function passed through argument \code{NP}.
When more than one ascendant node is needed, a first node is drawn randomly
among the ones allowed to bear descendents, then one or more node is drawn
randomly among the one located within a distance specified by argument
\code{maxDst} from the first node. When the number of ascendant nodes
satisfying these aforementioned conditions is smaller than the demanded
number, that smaller number is used instead.

The edges connecting each parental sequence to its immediate descendant is
written at each step into the edge list. Random
parent selection is done by randomly selecting one of the non-zero element of
the vector of numbers of descendents. As its name suggests this function
generate evolutionary sequences arranged as a tree rather than sequences
evolving linearly or along networks.
}
\examples{
## Reticulated sequence simulation

## Load the example of a configuration file provided with the
## package:
yaml.load_file(
  system.file(
    package = "PhyloSim",
    "extdata",
    "evolMod.yml"
  )
) -> dnaParam

## The configuration list is located in member `$DNA`
read.mutationMat(
  dnaParam$DNA 
) -> I

## The transition intensity matrix:
I

## Setting seed:
set.seed(12345)

## Generate the sequences:
simulate_network(
  I = I,
  NS = 300,
  NN = 150,
  NC = function() 1L + rpois(1L, 1.5),
  NP = function() 1L + rpois(1L, 0.5),
  verbose = FALSE
) -> res

## Get the concatenated sequences
original <- concatenate(res$sqn)
nogaps <-  concatenate(res$sqn, discard = "-")

## To save the sequences:
## write.fasta(original, "Simulated sequences - aligned.fst",
##             linebreak = 70L)
## write.fasta(nogaps, "Simulated sequences - raw.fst", linebreak = 70L)

## Function for showing sequence:
show.sequences <- function(
    x, xlim, ylim, xlab = "Position", text = FALSE,
    col=c(A="red",`T`="blue",C="green",G="yellow", `-`="grey"), ...) {
  
  par(mar=c(4,7,1,1))
  
  if(missing(xlim))
    xlim <- c(0,10*ceiling(max(sapply(x,nchar))/10))
  
  if(missing(ylim))
    ylim <- c(length(x), 0)
  
  dev.hold()
  
  plot(NA, xlim=xlim, ylim=ylim, axes=FALSE, xlab=xlab, ylab="", ...)
  
  axis(1L)
  
  axis(2L, at=1:length(x), labels = names(x), las=1)
  
  for(i in 1L:length(x)) {
    cc <- unlist(strsplit(x[i],""))
    for(j in 1L:length(cc)) {
      rect(j - 1, i - 0.5, j, i + 0.5, col = col[cc[j]], border = col[cc[j]])
      if(text) text(j - 0.5, i, cc[j], ...)
    }
  }
  
  dev.flush()
  
  invisible(NULL) 
  
}

## Showing the resulting sequences:
show.sequences(original, cex=0.75, font=2L)   ## Natively aligned
show.sequences(nogaps, cex=0.75, font=2L)     ## Raw

## Sequence simulation with traits

## Resetting RNG seed:
set.seed(12345)

## The trait evolution model parameters:
dnaParam$trait \%>\%
  lapply(read.TraitEvolMod) -> traitMod

## Generate the sequences with the traits:
simulate_network(
  I = I,
  NS = 300,
  NN = 150,
  traitMod = traitMod,
  initState = c(2,NA,1,1),
  initValue = c(50,0,15,-25),
  NC = function() 1L + rpois(1L, 1.5),
  NP = function() 1L + rpois(1L, 0.5)
) -> res2

## These are the trait evolution models that were used:
res2$trait$tem

## Obtain the nodes that are tips:
res2$edge \%>\%
  lapply(function(x) !length(x)) \%>\%
  unlist \%>\%
  which -> tips

getDescTrail <- function(net, desc) {
  trail <- desc
  while(TRUE) {
    net$edge \%>\%
      lapply(function(x, y) y \%in\% x, y = desc) \%>\%
      unlist \%>\%
      which -> asc
    if(!length(asc)) break
    if(length(asc) > 1L)
      sapply(
        asc,
        function(x) net$cont[[x]][net$edge[[x]] == desc]
      ) \%>\%
      which.min \%>\%
      asc[.] -> asc
    trail <- c(asc, trail)
    desc <- asc
  }
  trail
}

## Get the concatenated sequences
original2 <- concatenate(res2$sqn)

## Get the trail from the first tip:
show.sequences(
  original2[getDescTrail(res2, tips[1L])],
  cex=0.75,
  font=2L
)

## Get the trail from the tenth tip:
show.sequences(
  original2[getDescTrail(res2, tips[10L])],
  cex=0.75,
  font=2L
)

## Plot the trait simulation results for the first trail:
i <- getDescTrail(res2, tips[1L])

par(mar=c(4,4,1,1))
plot(NA, xlim=c(0,(length(i) - 1)), ylim=range(res2$trait$traitLog[i,]),
     xlab="Time", ylab="Trait value", las=1L)
lines(x=0:(length(i) - 1), y=res2$trait$traitLog[i,1L], col="black")
if(!is.na(res2$trait$tem[[1L]]$getOptima())[1L])
  lines(x=0:(length(i) - 1), y=res2$trait$optimLog[i,1L], col="black",
        lty=3L)
lines(x=0:(length(i) - 1), y=res2$trait$traitLog[i,2L], col="red")
if(!is.na(res2$trait$tem[[2L]]$getOptima())[1L])
  lines(x=0:(length(i) - 1), y=res2$trait$optimLog[i,2L], col="red", lty=3L)
lines(x=0:(length(i) - 1), y=res2$trait$traitLog[i,3L], col="blue")
if(!is.na(res2$trait$tem[[3L]]$getOptima())[1L])
  lines(x=0:(length(i) - 1), y=res2$trait$optimLog[i,3L], col="blue", lty=3L)
lines(x=0:(length(i) - 1), y=res2$trait$traitLog[i,4L], col="green")
if(!is.na(res2$trait$tem[[4L]]$getOptima())[1L])
  lines(x=0:(length(i) - 1), y=res2$trait$optimLog[i,4L], col="green",
        lty=3L)

## Plot the trait simulation results for the tenth trail:
i <- getDescTrail(res2, tips[10L])

par(mar=c(4,4,1,1))
plot(NA, xlim=c(0,(length(i) - 1)), ylim=range(res2$trait$traitLog[i,]),
     xlab="Time", ylab="Trait value", las=1L)
lines(x=0:(length(i) - 1), y=res2$trait$traitLog[i,1L], col="black")
if(!is.na(res2$trait$tem[[1L]]$getOptima())[1L])
  lines(x=0:(length(i) - 1), y=res2$trait$optimLog[i,1L], col="black",
        lty=3L)
lines(x=0:(length(i) - 1), y=res2$trait$traitLog[i,2L], col="red")
if(!is.na(res2$trait$tem[[2L]]$getOptima())[1L])
  lines(x=0:(length(i) - 1), y=res2$trait$optimLog[i,2L], col="red", lty=3L)
lines(x=0:(length(i) - 1), y=res2$trait$traitLog[i,3L], col="blue")
if(!is.na(res2$trait$tem[[3L]]$getOptima())[1L])
  lines(x=0:(length(i) - 1), y=res2$trait$optimLog[i,3L], col="blue", lty=3L)
lines(x=0:(length(i) - 1), y=res2$trait$traitLog[i,4L], col="green")
if(!is.na(res2$trait$tem[[4L]]$getOptima())[1L])
  lines(x=0:(length(i) - 1), y=res2$trait$optimLog[i,4L], col="green",
        lty=3L)

## Clean up:
rm(dnaParam,I,traitMod,res,res2,nogaps,original,original2,show.sequences,
   getDescTrail,i,tips)

}
\author{
\packageAuthor{PhyloSim}
}
