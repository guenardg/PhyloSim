% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulate_tree.R
\name{simulate_tree}
\alias{simulate_tree}
\title{Simulation of DNA Linear Sequences Evolution Along the Edge of a Tree}
\usage{
simulate_tree(
  I,
  NN,
  NS,
  traitMod,
  initState,
  initValue,
  NC = function() 2L,
  gamma.shape = 5,
  gamma.scale = 5e-04,
  timestep = 1,
  prob = c(0.3, rep(0.175, 4L)),
  removeGapOnly = TRUE,
  verbose = TRUE
)
}
\arguments{
\item{I}{A 5 x 5 transition intensity matrix such as the one obtained from
function \code{read.mutationMat}.}

\item{NN}{The number of nucleotides for each of the sequence.}

\item{NS}{The number of sequences to generate.}

\item{traitMod}{Trait evolution parameters used to generate trait values
alongside the sequences (optional, no trait is generated when missing).}

\item{initState}{If argument \code{traitMod} is given, the initial state of
traits with multiple optima is specified by this argument (mandatory when
argument \code{traitMod} is given, see details).}

\item{initValue}{If argument \code{traitMod} is given, the initial state of
traits with multiple optima is specified by this argument (see details).}

\item{NC}{A function returning the number of descendents for each new node
created (default: a function returning the value 2).}

\item{gamma.shape}{Shape parameter of the gamma distribution from which the
evolution rates are drawn (see details).}

\item{gamma.scale}{Scale parameter of the gamma distribution from which the
evolution rates are drawn (see details).}

\item{timestep}{Time step of the simulation (default: 1 arbitrary unit of
time per generation).}

\item{prob}{A vector of length 5 giving the probabilities for drawing a gap,
or any one of the four bases (gap, adenine, cytosine, guanine, thymine, in
that order) when generating the first sequence (the ancestor of all the
others; default: \code{c(0.3, 0.175, 0.175, 0.175, 0.175)}).}

\item{removeGapOnly}{A boolean specifying whether gap-only locations should
by removed.}

\item{verbose}{A boolean specifying whether to display information about the
links as the sequences are being created (default: \code{TRUE}).}
}
\value{
A \code{\link{list}} containing the following members:
\describe{
\item{trait}{ A list containing the simulation data for the trait value (see
details). }
\item{rate}{ A numeric vector of the evolution rates of each location (bases
or gaps). }
\item{em}{ A list of molecular evolution models, one for each location. }
\item{sqn}{ A raw matrix containing the sequences, whereby sequences are the
rows and locations are the columns). }
\item{cld}{ Am integer vector giving the number of remaining descendents
per node at the end of the simulation process. }
\item{dst}{ A matrix of the distances among the sequences, in terms of the
numbers of time steps between them. }
\item{edge}{ A list of two integer vectors containing the starting points and
end points of each edge connecting ancestor and descendent sequences. }
}
}
\description{
A function to simulate a set of DNA sequences along the edge of
a random phylogenetic tree.
}
\details{
The function generate a random tree with simulated DNA data by
evolving a set of nucleotides using Markov chain based molecular evolution
models as implemented using function \code{\link{molEvolMod}}. Optionally,
the function can simulate the evolution of a set of quantitative traits using
the approach implemented by function \code{\link{traitEvolMod}}.

The process begins by drawing a set of evolution rates from a gamma
distribution with shape and scale parameters provided from arguments
\code{gamma.shape} and \code{gamma.scale}, respectively, for each of a set of
locations whose number of given by argument \code{NS}. When applicable,
Molecular evolution models generated by function \code{\link{molEvolMod}} are
then implemented individually for each location from the randomly drawn rates
and the transition intensity matrix obtained from a YAML configuration file
using function \code{\link{read.mutationMat}}. Then, an initial DNA sequence
is generated using the probabilities (for gaps or any of the ACGT bases)
provided by argument \code{prob}. Also, a vector of numbers of descendents
per node is is initialized with zeros. Non-zero elements of this vectors
indicate nodes that are allowed to have descendents. With each reproduction
event, the value is decremented by one until the value goes back to zero.
Initial values of this descendant vector are generated by the function passed
through argument \code{NC}.

Once these staging steps are done, each sequence is generated by evolving
each location of the selected ancestral sequence using the molecular
evolution models until the prescribed number of sequences, provided by
argument \code{NS}, is reached. The edges connecting each parental sequence
to its immediate descendant is written at each step into the edge list.
Random parent selection is done by randomly selecting one of the non-zero
element of the vector of numbers of descendents. As its name suggests this
function generate evolutionary sequences arranged as a tree rather than
sequences evolving linearly or along networks.
}
\examples{
## Load the example of a configuration file provided with the
## package:
yaml.load_file(
  system.file(
    package = "PhyloSim",
    "extdata",
    "evolMod.yml"
  )
) -> dnaParam

## The configuration list is located in member `$DNA`
read.mutationMat(
  dnaParam$DNA 
) -> I

## The transition intensity matrix:
I

## Setting seed:
set.seed(12345)

## Generate the sequences:
simulate_tree(
  I = I,
  NS = 300,
  NN = 150
) -> res

## Get the concatenated sequences
original <- concatenate(res$sqn)
nogaps <-  concatenate(res$sqn, discard = "-")

## To save the sequences:
## write.fasta(original, "Simulated sequences - aligned.fst",
##             linebreak = 70L)
## write.fasta(nogaps, "Simulated sequences - raw.fst", linebreak = 70L)

## Function for showing sequence:
show.sequences <- function(
  x, xlim, ylim, xlab = "Position", text = FALSE,
  col=c(A="red",`T`="blue",C="green",G="yellow", `-`="grey"), ...) {

  par(mar=c(4,7,1,1))

  if(missing(xlim))
    xlim <- c(0,10*ceiling(max(sapply(x,nchar))/10))

  if(missing(ylim))
    ylim <- c(length(x), 0)

  dev.hold()

  plot(NA, xlim=xlim, ylim=ylim, axes=FALSE, xlab=xlab, ylab="", ...)

  axis(1L)

  axis(2L, at=1:length(x), labels = names(x), las=1)

  for(i in 1L:length(x)) {
    cc <- unlist(strsplit(x[i],""))
    for(j in 1L:length(cc)) {
      rect(j - 1, i - 0.5, j, i + 0.5, col = col[cc[j]], border = col[cc[j]])
      if(text) text(j - 0.5, i, cc[j], ...)
    }
  }

  dev.flush()
  
  invisible(NULL) 

}

## Showing the resulting sequences:
show.sequences(original, cex=0.75, font=2L)   ## Natively aligned
show.sequences(nogaps, cex=0.75, font=2L)     ## Raw


## Sequence simulation with traits

## Resetting RNG seed:
set.seed(12345)

## The trait evolution model parameters:
dnaParam$trait \%>\%
  lapply(read.TraitEvolMod) -> traitMod

## Generate the sequences with the traits:
simulate_tree(
  I = I,
  NS = 300,
  NN = 150,
  traitMod = traitMod,
  initState = c(2,NA,1,1),
  initValue = c(50,0,15,-25)
) -> res2

## These are the trait evolution models that were used:
res2$trait$tem


## Obtain the nodes that are tips:
res2$edge \%>\%
  {unique(.$to)[!(unique(.$to) \%in\% unique(.$from))]} \%>\%
  {.[order(.)]} -> tips

## A function to obtain all the descendents from a tip:
getDescendents <- function(x, y) {
  while(head(y,1L) != 1)
    y <- c(x$edge$from[head(y,1L) == x$edge$to],y)
  y
}

## Get the concatenated sequences
original2 <- concatenate(res2$sqn)

## Get the trail from the first tip:
show.sequences(
  original2[getDescendents(res2, tips[1L])],
  cex=0.75,
  font=2L
)

## Get the trail from the tenth tip:
show.sequences(
  original2[getDescendents(res2, tips[10L])],
  cex=0.75,
  font=2L
)

## Plot the trait simulation results for the first trail:
i <- getDescendents(res2, tips[10L])

par(mar=c(4,4,1,1))
plot(NA, xlim=c(0,(length(i) - 1)), ylim=range(res2$trait$traitLog[i,]),
     xlab="Time", ylab="Trait value", las=1L)
lines(x=0:(length(i) - 1), y=res2$trait$traitLog[i,1L], col="black")
if(!is.na(res2$trait$tem[[1L]]$getOptima())[1L])
  lines(x=0:(length(i) - 1), y=res2$trait$optimLog[i,1L], col="black",
        lty=3L)
lines(x=0:(length(i) - 1), y=res2$trait$traitLog[i,2L], col="red")
if(!is.na(res2$trait$tem[[2L]]$getOptima())[1L])
  lines(x=0:(length(i) - 1), y=res2$trait$optimLog[i,2L], col="red", lty=3L)
lines(x=0:(length(i) - 1), y=res2$trait$traitLog[i,3L], col="blue")
if(!is.na(res2$trait$tem[[3L]]$getOptima())[1L])
  lines(x=0:(length(i) - 1), y=res2$trait$optimLog[i,3L], col="blue", lty=3L)
lines(x=0:(length(i) - 1), y=res2$trait$traitLog[i,4L], col="green")
if(!is.na(res2$trait$tem[[4L]]$getOptima())[1L])
  lines(x=0:(length(i) - 1), y=res2$trait$optimLog[i,4L], col="green",
        lty=3L)

## Plot the trait simulation results for the tenth trail:
i <- getDescendents(res2, tips[10L])

par(mar=c(4,4,1,1))
plot(NA, xlim=c(0,(length(i) - 1)), ylim=range(res2$trait$traitLog[i,]),
     xlab="Time", ylab="Trait value", las=1L)
lines(x=0:(length(i) - 1), y=res2$trait$traitLog[i,1L], col="black")
if(!is.na(res2$trait$tem[[1L]]$getOptima())[1L])
  lines(x=0:(length(i) - 1), y=res2$trait$optimLog[i,1L], col="black",
        lty=3L)
lines(x=0:(length(i) - 1), y=res2$trait$traitLog[i,2L], col="red")
if(!is.na(res2$trait$tem[[2L]]$getOptima())[1L])
  lines(x=0:(length(i) - 1), y=res2$trait$optimLog[i,2L], col="red", lty=3L)
lines(x=0:(length(i) - 1), y=res2$trait$traitLog[i,3L], col="blue")
if(!is.na(res2$trait$tem[[3L]]$getOptima())[1L])
  lines(x=0:(length(i) - 1), y=res2$trait$optimLog[i,3L], col="blue", lty=3L)
lines(x=0:(length(i) - 1), y=res2$trait$traitLog[i,4L], col="green")
if(!is.na(res2$trait$tem[[4L]]$getOptima())[1L])
  lines(x=0:(length(i) - 1), y=res2$trait$optimLog[i,4L], col="green",
        lty=3L)

## Clean up:
rm(dnaParam,I,traitMod,res,res2,nogaps,original,original2,show.sequences,
   getDescendents,i,tips)

}
\author{
\packageAuthor{PhyloSim}
}
