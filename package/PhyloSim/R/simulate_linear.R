## **************************************************************************
##
##    (c) 2023 Guillaume Guénard
##        Department de sciences biologiques,
##        Université de Montréal
##        Montreal, QC, Canada
##
##    ** Simulation of DNA sequences evolution - linear sequential case **
##
##    This file is part of PhyloSim
##
##    PhyloSim is free software: you can redistribute it and/or modify
##    it under the terms of the GNU General Public License as published by
##    the Free Software Foundation, either version 3 of the License, or
##    (at your option) any later version.
##
##    PhyloSim is distributed in the hope that it will be useful,
##    but WITHOUT ANY WARRANTY; without even the implied warranty of
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##    GNU General Public License for more details.
##
##    You should have received a copy of the GNU General Public License
##    along with PhyloSim. If not, see <https://www.gnu.org/licenses/>.
##
##    R source code file
##
## **************************************************************************
##
#' @name simulate_linear
#' 
#' @title Simulation of DNA Linear Sequences Evolution in a Linear Sequential
#' Way
#' 
#' @description A function to simulate a set of DNA sequences where each element
#' (besides the first one) is the direct descendant of the previous one.
#' 
#' @param I A 5 x 5 transition intensity matrix such as the one obtained from
#' function \code{read.mutationMat}.
#' @param NS The number of sequences to generate.
#' @param NN The number of nucleotides for each of the sequence.
#' @param traitMod Trait evolution parameters used to generate trait values
#' alongside the sequences (optional, no trait is generated when missing).
#' @param initState If argument \code{traitMod} is given, the initial state of
#' traits with multiple optima is specified by this argument (mandatory when
#' argument \code{traitMod} is given, see details).
#' @param initValue If argument \code{traitMod} is given, the initial state of
#' traits with multiple optima is specified by this argument (see details).
#' @param gamma.shape Shape parameter of the gamma distribution from which the
#' evolution rates are drawn (see details).
#' @param gamma.scale Scale parameter of the gamma distribution from which the
#' evolution rates are drawn (see details).
#' @param timestep Time step of the simulation (default: 1 arbitrary unit of
#' time per generation).
#' @param prob A vector of length 5 giving the probabilities for drawing a gap,
#' or any one of the four bases (gap, adenine, cytosine, guanine, thymine, in
#' that order) when generating the first sequence (the ancestor of all the
#' others; default: \code{c(0.3, 0.175, 0.175, 0.175, 0.175)}).
#' @param removeGapOnly A boolean specifying whether gap-only locations should
#' by removed.
#' @param verbose A boolean specifying whether to display information about the
#' links as the sequences are being created (default: \code{TRUE}).
#' 
#' @returns A \code{\link{list}} containing the following members:
#' \describe{
#' \item{trait}{ A list containing the simulation data for the trait value (see
#' details). }
#' \item{rate}{ A numeric vector of the evolution rates of each location (bases
#' or gaps). }
#' \item{em}{ A list of molecular evolution models, one for each location. }
#' \item{sqn}{ A raw matrix containing the sequences, whereby sequences are the
#' rows and locations are the columns). }
#' \item{dst}{ A matrix of the distances among the sequences, in terms of the
#' numbers of time steps between them. }
#' \item{edge}{ A list of two integer vectors containing the starting points and
#' end points of each edge connecting ancestor and descendent sequences. }
#' }
#' 
#' @details The function generate a ``linear'' sequence of simulated DNA data by
#' evolving a set of nucleotides using Markov chain based molecular evolution
#' models as implemented using function \code{\link{molEvolMod}}. Optionally,
#' the function can simulate the evolution of a set of quantitative traits using
#' the approach implemented by function \code{\link{traitEvolMod}}.
#' 
#' The process begins by drawing a set of evolution rates from a gamma
#' distribution with shape and scale parameters provided from arguments
#' \code{gamma.shape} and \code{gamma.scale}, respectively, for each of a set of
#' locations whose number of given by argument \code{NS}. When applicable,
#' Molecular evolution models generated by function \code{\link{molEvolMod}} are
#' then implemented individually for each location from the randomly drawn rates
#' and thetransition intensity matrix obtained from a YAML configuration file
#' using function \code{\link{read.mutationMat}}. Then, an initial DNA sequence
#' is generated using the probabilities (for gaps or any of the ACGT bases)
#' provided by argument \code{prob}.
#' 
#' Once these staging steps are done, each sequence is generated by evolving
#' each location of the previously generated sequence using the molecular
#' evolution models until the prescribed number of sequences, provided by
#' argument \code{NS}, is reached. The edges connecting each parental sequence
#' to its immediate sibbling is written at each step into the edge list. As its
#' name suggests this function generate strictly linear evolutionary sequences
#' rather than sequences evolving along evolutionary trees or networks.
#' 
#' @author \packageAuthor{PhyloSim}
#' 
#' @import magrittr
#' @importFrom stats rgamma
#' 
#' @examples ## Load the example of a configuration file provided with the
#' ## package:
#' yaml.load_file(
#'   system.file(
#'     package = "PhyloSim",
#'     "extdata",
#'     "evolMod.yml"
#'   )
#' ) -> dnaParam
#' 
#' ## The configuration list is located in member `$DNA`
#' read.mutationMat(
#'   dnaParam$DNA 
#' ) -> I
#' 
#' ## The transition intensity matrix:
#' I
#' 
#' ## Setting seed:
#' set.seed(12345)
#' 
#' ## Generate the sequences:
#' simulate_linear(
#'   I = I,
#'   NS = 35,
#'   NN = 150,
#'   gamma.shape = 5,
#'   gamma.scale = 5e-4,
#'   timestep = 1
#' ) -> res
#' 
#' ## Get the concatenated sequences
#' original <- concatenate(res$sqn)
#' nogaps <-  concatenate(res$sqn, discard = "-")
#' 
#' ## To save the sequences:
#' ## write.fasta(original, "Simulated sequences - aligned.fst",
#' ##             linebreak = 70L)
#' ## write.fasta(nogaps, "Simulated sequences - raw.fst", linebreak = 70L)
#' 
#' ## Function for showing sequence:
#' show.sequences <- function(
#'   x, xlim, ylim, xlab = "Position", text = FALSE,
#'   col=c(A="red",`T`="blue",C="green",G="yellow", `-`="grey"), ...) {
#' 
#'   par(mar=c(4,7,1,1))
#' 
#'   if(missing(xlim))
#'     xlim <- c(0,10*ceiling(max(sapply(x,nchar))/10))
#' 
#'   if(missing(ylim))
#'     ylim <- c(length(x), 0)
#' 
#'   dev.hold()
#' 
#'   plot(NA, xlim=xlim, ylim=ylim, axes=FALSE, xlab=xlab, ylab="", ...)
#' 
#'   axis(1L)
#' 
#'   axis(2L, at=1:length(x), labels = names(x), las=1)
#' 
#'   for(i in 1L:length(x)) {
#'     cc <- unlist(strsplit(x[i],""))
#'     for(j in 1L:length(cc)) {
#'       rect(j - 1, i - 0.5, j, i + 0.5, col = col[cc[j]], border = col[cc[j]])
#'       if(text) text(j - 0.5, i, cc[j], ...)
#'     }
#'   }
#' 
#'   dev.flush()
#'   
#'   invisible(NULL) 
#' 
#' }
#' 
#' ## Showing the resulting sequences:
#' show.sequences(original, cex=0.75, font=2L)   ## Natively aligned
#' show.sequences(nogaps, cex=0.75, font=2L)     ## Raw
#' 
#' 
#' ## Sequence simulation with traits
#' 
#' ## Resetting RNG seed:
#' set.seed(12345)
#' 
#' ## The trait evolution model parameters:
#' dnaParam$trait %>%
#'   lapply(read.TraitEvolMod) -> traitMod
#' 
#' ## Generate the sequences:
#' simulate_linear(
#'   I = I,
#'   NS = 300,
#'   NN = 150,
#'   traitMod = traitMod,
#'   initState = c(2,NA,1,1),
#'   initValue = c(50,0,15,-25),
#'   gamma.shape = 5,
#'   gamma.scale = 5e-4,
#'   timestep = 1
#' ) -> res2
#' 
#' ## These are the trait evolution models that were used:
#' res2$trait$tem
#' 
#' ## Plot the trait simulation results:
#' par(mar=c(4,4,1,1))
#' plot(NA, xlim=c(0,300), ylim=range(res2$trait$traitLog), xlab="Time",
#'      ylab="Trait value", las=1L)
#' lines(x=0:299, y=res2$trait$traitLog[,1L], col="black")
#' if(!is.na(res2$trait$tem[[1L]]$getOptima())[1L])
#'   lines(x=0:299, y=res2$trait$optimLog[,1L], col="black", lty=3L)
#' lines(x=0:299, y=res2$trait$traitLog[,2L], col="red")
#' if(!is.na(res2$trait$tem[[2L]]$getOptima())[1L])
#'   lines(x=0:299, y=res2$trait$optimLog[,2L], col="red", lty=3L)
#' lines(x=0:299, y=res2$trait$traitLog[,3L], col="blue")
#' if(!is.na(res2$trait$tem[[3L]]$getOptima())[1L])
#'   lines(x=0:299, y=res2$trait$optimLog[,3L], col="blue", lty=3L)
#' lines(x=0:299, y=res2$trait$traitLog[,4L], col="green")
#' if(!is.na(res2$trait$tem[[4L]]$getOptima())[1L])
#'   lines(x=0:299, y=res2$trait$optimLog[,4L], col="green", lty=3L)
#' 
#' original2 <- concatenate(res2$sqn)
#' 
#' show.sequences(original2, cex=0.75, font=2L)
#' 
#' ## Clean up:
#' rm(dnaParam,I,traitMod,res,res2,nogaps,original,original2,show.sequences)
#' 
#' @export
simulate_linear <- function(I, NN, NS, traitMod, initState, initValue,
                            gamma.shape = 5, gamma.scale = 5e-4, timestep = 1,
                            prob = c(0.3,rep(0.175,4L)), removeGapOnly = TRUE,
                            verbose = TRUE) {
  
  ## Result list:
  out <- list()
  
  ## Should we also simulate trait evolution alongside the sequences?
  simTrait <- !missing(traitMod)
  
  ## Create the trait evolution models and the log files:
  if(simTrait) {
    
    out$trait <- list(tem = lapply(traitMod, traitEvolMod))
    trNms <- lapply(out$trait$tem, function(x) x$getName())
    NT <- length(trNms)
    out$trait$stateLog <- matrix(NA, NS, NT, dimnames = list(NULL, trNms))
    out$trait$optimLog <- matrix(NA, NS, NT, dimnames = list(NULL, trNms))
    out$trait$traitLog <- matrix(NA, NS, NT, dimnames = list(NULL, trNms))
    
    if(!missing(initState)) {
      out$trait$stateLog[1L,] <- initState
    } else
      stop("Missing initial trait state(s)!")
    
    out$trait$tem %>%
      lapply(
        function(x)
          x$getOptima()[out$trait$stateLog[1L,x$getName()]]
      ) %>%
      unlist -> out$trait$optimLog[1L,]
    
    if(!missing(initValue)) {
      out$trait$traitLog[1L,] <- initValue
    } else {
      warning("Initial trait values missing! Assumed to be 0")
      out$trait$traitLog[1L,] <- 0
    }
    
  }
  
  ## Draw the evolution rates for each locations:
  rgamma(
    NN,
    shape = gamma.shape,
    scale = gamma.scale
  ) -> out$rate
  
  ## Create the nucleotides evolution models from the mutation intensity matrix
  ## I a the specified time step, and the evolution rates drawn previously:
  out$em <- list()
  for(i in 1L:NN)
    out$em[[i]] <- molEvolMod(I, timestep, out$rate[i])
  
  ## A matrix to store NS sequences of NN locations each:
  out$sqn <- matrix(raw(), NS, NN)
  
  ## Generate an initial sequence. The sequence has around 30% of gaps and the
  ## remaining 70% of the locations are evenly drawn among the 4 nucleotide
  ## bases. The role of the gaps is to allow the simulation of nuclotide
  ## insertion or deletion. A gap turning into a nucleotide simulate an
  ## insertion and a nucleotide turning into a gap simulates a deletion.
  sample(
    x = charToRaw("-ACGT"),
    size = NN,
    prob = prob,
    replace = TRUE
  ) -> out$sqn[1L,]
  
  ## Dissimilarity vector (in terms of the time step):
  out$dst <- rep(NA,NS*(NS - 1L)/2)
  
  out$edge <- list(from=c(), to=c())
  
  ## Sequence generation loops:
  for(i in 2L:NS) {
    for(j in 1L:NN)
      out$sqn[i,j] <- out$em[[j]]$evolve(out$sqn[i - 1,j])
    
    ## 1. Insert the time in the locations:
    out$dst[dst_idx(NS, i, i - 1)] <- timestep
    
    ## 2. Add the time to all other distances for active nodes:
    if(i > 2L) {
      idx_k_others <- dst_idx(NS, i - 1, (1:i)[-c(i,i - 1)])
      idx_i_others <- dst_idx(NS, i, (1:i)[-c(i,i - 1)])
      out$dst[idx_i_others] <- out$dst[idx_k_others] + timestep
    }
    
    ## 3. Add the new edge to the edge list
    out$edge$from <- c(out$edge$from, i - 1L)
    out$edge$to <- c(out$edge$to, i)
    
    ## Evolve each traits
    if(simTrait) {
      
      out$trait$tem %>%
        lapply(
          function(x)
            x$updateState(out$trait$stateLog[i - 1L,x$getName()])
        ) %>%
        unlist -> out$trait$stateLog[i,]
      
      out$trait$tem %>%
        lapply(
          function(x)
            x$getOptima()[out$trait$stateLog[i,x$getName()]]
        ) %>%
        unlist -> out$trait$optimLog[i,]
      
      out$trait$tem %>%
        lapply(
          function(x)
            x$updateValue(
              state = out$trait$stateLog[i,x$getName()],
              value = out$trait$traitLog[i - 1L,x$getName()]
            )
        ) %>%
        unlist -> out$trait$traitLog[i,]
      
    }
    
    if(verbose) {
      cat(sprintf("%04d -> %04d (%f)",i - 1L,i,out$dst[dst_idx(NS, 1L, i)]))
      if(simTrait) {
        cat(paste(sprintf(" %0.3f",out$trait$traitLog[i,]),collapse=", "),"\n")
      } else
        cat("\n")
    }
    
  }
  
  ## Transform the dissimilarity vector into a dist-class object:
  list(
    Size = NS,
    Diag = FALSE,
    Upper = FALSE,
    method = "patristic",
    call = match.call(),
    class = "dist"
  ) -> attributes(out$dst)
  
  ## Purge gap-only locations:
  if(removeGapOnly)
    out$sqn %<>% .[,apply(., 2L, function(x) !all(x == charToRaw("-")))]
  
  ## Give a name to the sequences
  rownames(out$sqn) <- sprintf("sequence%04d", 1L:NS)
  
  out
}
#'
